library(lubridate)
d <- read.table("sof.hypnos",header=T,stringsAsFactors=F)
View(d)
d
d(1000:2000)
View(d)
d[500:600,]
View(d)
d[500:1600,]
d[1200:1600,]
names(d)
names(d)[4] <- "SS"
names(d)
ni <- length( unique( d$ID ) )
ni
nf <- length( d$ID[ d$E == 1 ] )
nf
d1 <- d[ d$E == 1 , ]
d1
secs <- lubridate::period_to_seconds( lubridate::hms( d1$CLOCK_TIME ) )
secs
d1
View(d1)
secs
secs <- 30 * floor( secs / 30 )
secs
secs[ secs < 43200 ]
secs[ secs < 43200 ] <- secs[ secs < 43200 ] + 86400
secs
td <- seconds_to_period( min( secs ) )
td
min(secs)
td@hour
first.epoch <- sprintf( '%02d:%02d:%02d', td@hour, minute(td), second(td) )
first.epoch
d1
names(D1)
names(d1)
d1$E1 <- ( secs - min( secs ) ) / 30
d1
0/30
secs
min(secs)
secs - min(secs)
View(d1)
min(d1$E1)
d <- merge( d , d1[ , c("ID","E1") ] , by="ID" )
d$EA <- d$E + d$E1
View(d)
d$SS
d$SLEEP <- as.integer( d$SS %in% c( "N1","N2","N3","R") )
d$SLEEP
d$SS
d1 <- as.data.frame( tapply( d$EA[ d$SLEEP == 1 ]  , d$ID[ d$SLEEP == 1 ] , min )   )
d1
View(d1)
names(d1) <- "T2"
View(d1)
d1$ID <- rownames( d1 )
View(d1)
d <- merge( d , d1[ , c("ID","T2") ] , by="ID" , all.x = T )
d
d$E2 <- d$EA - d$T2
d
dmin <- tapply( d$EA , d$ID , min )
dmax <- tapply( d$EA , d$ID , max )
ids <- unique( d$ID )
ne <- max( d$EA ) - min( d$EA ) + 1
m <- matrix( NA , nrow = ne , ncol = ni )
for (i in 1:ni) m[ (dmin[i]):(dmax[i]) , i ] <- 4 + lstgn( d$SS[ d$ID == ids[i] ]  )
library(luna)
lstgn
dmin <- tapply( d$EA , d$ID , min )
dmax <- tapply( d$EA , d$ID , max )
ids <- unique( d$ID )
ne <- max( d$EA ) - min( d$EA ) + 1
m <- matrix( NA , nrow = ne , ncol = ni )
for (i in 1:ni) m[ (dmin[i]):(dmax[i]) , i ] <- 4 + lstgn( d$SS[ d$ID == ids[i] ]  )
stgpal <- c(lstgcols("N3"), lstgcols("N2"), lstgcols("N1"),
lstgcols("R"), lstgcols("W"), lstgcols("?"))
stgpal
image(m, useRaster=T , col = stgpal, xaxt = "n", yaxt = "n", axes = F, breaks = 0.5 + (0:6) )
library(luna)
library(lubridate)
d <- read.table("sof.hypnos",header=T,stringsAsFactors=F)
names(d)[4] <- "SS"
d
d1 <- d[ d$E == 1 , ]
d1
secs <- lubridate::period_to_seconds( lubridate::hms( d1$CLOCK_TIME ) )
secs
# Align to 30 sec epoch
secs <- 30 * floor( secs / 30 )
secs
# Need clarification ( secs less than 12 hrs )
secs[ secs < 43200 ] <- secs[ secs < 43200 ] + 86400
secs
td <- seconds_to_period( min( secs ) )
first.epoch <- sprintf( '%02d:%02d:%02d', td@hour, minute(td), second(td) )
first.epoch
View(d1)
70260 - min(secs)
2400/30
secs
min(secs)
86340 - 67860
18480/30
d1$E1 <- ( secs - min( secs ) ) / 30
View(d1)
View(d1)
View(d)
View(d1)
d <- merge( d , d1[ , c("ID","E1") ] , by="ID" )
View(d)
View(d)
d$EA <- d$E + d$E1
View(d)
d[1:616,]
d[612:616,]
d[612:617,]
d[612:618,]
d[612:634,]
d[650:655,]
d[650:800,]
d[838:845,]
616+840
View(d)
View(d)
d$SLEEP <- as.integer( d$SS %in% c( "N1","N2","N3","R") )
d1 <- as.data.frame( tapply( d$EA[ d$SLEEP == 1 ]  , d$ID[ d$SLEEP == 1 ] , min )   )
names(d1) <- "T2"
d1$ID <- rownames( d1 )
View(d)
View(d1)
View(d)
View(d1)
View(d)
View(d1)
View(d1)
d <- merge( d , d1[ , c("ID","T2") ] , by="ID" , all.x = T )
View(d)
d$E2 <- d$EA - d$T2
View(d)
dmin <- tapply( d$EA , d$ID , min )
dmin
View(d)
dmax <- tapply( d$EA , d$ID , max )
dmax
ids <- unique( d$ID )
ids
ne <- max( d$EA ) - min( d$EA ) + 1
ne
d$EA
ne
min(d$EA)
max(d$EA)
length(d)
nrows(D)
nrows(d)
ni
m <- matrix( NA , nrow = ne , ncol = ni )
dmin <- tapply( d$EA , d$ID , min )
dmax <- tapply( d$EA , d$ID , max )
ids <- unique( d$ID )
ne <- max( d$EA ) - min( d$EA ) + 1
m <- matrix( NA , nrow = ne , ncol = ni )
library(luna)
library(lubridate)
d <- read.table("sof.hypnos",header=T,stringsAsFactors=F)
names(d)[4] <- "SS"
# Get first epoch for each individual
d1 <- d[ d$E == 1 , ]
# Convert HMS to seconds
secs <- lubridate::period_to_seconds( lubridate::hms( d1$CLOCK_TIME ) )
# Align to 30 sec epoch
secs <- 30 * floor( secs / 30 )
# Need clarification ( secs less than 12 hrs )
secs[ secs < 43200 ] <- secs[ secs < 43200 ] + 86400
# Get earliest time point
td <- seconds_to_period( min( secs ) )
first.epoch <- sprintf( '%02d:%02d:%02d', td@hour, minute(td), second(td) )
# Get epoch-wise starts for all people
d1$E1 <- ( secs - min( secs ) ) / 30
# Adjust epoch counts : EA = aligned epochs (by clock)
d <- merge( d , d1[ , c("ID","E1") ] , by="ID" )
d$EA <- d$E + d$E1
# Get key anchors for each individual: sleep onset / offset, lights, sleep midpoint
d$SLEEP <- as.integer( d$SS %in% c( "N1","N2","N3","R") )
d1 <- as.data.frame( tapply( d$EA[ d$SLEEP == 1 ]  , d$ID[ d$SLEEP == 1 ] , min )   )
names(d1) <- "T2"
d1$ID <- rownames( d1 ) # Timed epoch when subject starts to sleep
# nb. do not assume all individuals will have sleep... thus all.x = T
d <- merge( d , d1[ , c("ID","T2") ] , by="ID" , all.x = T )
# Align to T2 == 0
d$E2 <- d$EA - d$T2
# Plot for clock-alignment
dmin <- tapply( d$EA , d$ID , min )
dmax <- tapply( d$EA , d$ID , max )
ids <- unique( d$ID )
ne <- max( d$EA ) - min( d$EA ) + 1
m <- matrix( NA , nrow = ne , ncol = ni )
View(d)
View(d)
ni <- length( unique( d$ID ) )
nf <- length( d$ID[ d$E == 1 ] )
if ( ni != nf ) {
cat( "not all indivs have first epoch (E==1)...\n" )
d <- d[ d$ID %in% d$ID[ d$E == 1 ] , ]
}
m <- matrix( NA , nrow = ne , ncol = ni )
m
dim(m)
for (i in 1:ni) m[ (dmin[i]):(dmax[i]) , i ] <- 4 + lstgn( d$SS[ d$ID == ids[i] ]  )
View(m)
View(m)
dim(m)
stgpal <- c(lstgcols("N3"), lstgcols("N2"), lstgcols("N1"),
lstgcols("R"), lstgcols("W"), lstgcols("?"))
image(m, useRaster=T , col = stgpal, xaxt = "n", yaxt = "n", axes = F, breaks = 0.5 + (0:6) )
library(luna)
library(lubridate)
d <- read.table("sof.hypnos",header=T,stringsAsFactors=F)
names(d)[4] <- "SS"
ni <- length( unique( d$ID ) )
nf <- length( d$ID[ d$E == 1 ] )
if ( ni != nf ) {
cat( "not all indivs have first epoch (E==1)...\n" )
d <- d[ d$ID %in% d$ID[ d$E == 1 ] , ]
}
# Get first epoch for each individual
d1 <- d[ d$E == 1 , ]
# Convert HMS to seconds
secs <- lubridate::period_to_seconds( lubridate::hms( d1$CLOCK_TIME ) )
# Align to 30 sec epoch
secs <- 30 * floor( secs / 30 )
# Need clarification ( secs less than 12 hrs )
secs[ secs < 43200 ] <- secs[ secs < 43200 ] + 86400
# Get earliest time point
td <- seconds_to_period( min( secs ) )
first.epoch <- sprintf( '%02d:%02d:%02d', td@hour, minute(td), second(td) )
td
# Get epoch-wise starts for all people
d1$E1 <- ( secs - min( secs ) ) / 30
View(d1)
# Adjust epoch counts : EA = aligned epochs (by clock)
d <- merge( d , d1[ , c("ID","E1") ] , by="ID" )
d$EA <- d$E + d$E1
# Get key anchors for each individual: sleep onset / offset, lights, sleep midpoint
d$SLEEP <- as.integer( d$SS %in% c( "N1","N2","N3","R") )
d1 <- as.data.frame( tapply( d$EA[ d$SLEEP == 1 ]  , d$ID[ d$SLEEP == 1 ] , min )   )
names(d1) <- "T2"
d1$ID <- rownames( d1 ) # Timed epoch when subject starts to sleep
# nb. do not assume all individuals will have sleep... thus all.x = T
d <- merge( d , d1[ , c("ID","T2") ] , by="ID" , all.x = T )
View(d1)
View(d)
View(d)
# Align to T2 == 0
d$E2 <- d$EA - d$T2
View(d)
# Plot for clock-alignment
dmin <- tapply( d$EA , d$ID , min )
dmax <- tapply( d$EA , d$ID , max )
ids <- unique( d$ID )
ne <- max( d$EA ) - min( d$EA ) + 1
m <- matrix( NA , nrow = ne , ncol = ni )
for (i in 1:ni) m[ (dmin[i]):(dmax[i]) , i ] <- 4 + lstgn( d$SS[ d$ID == ids[i] ]  )
stgpal <- c(lstgcols("N3"), lstgcols("N2"), lstgcols("N1"),
lstgcols("R"), lstgcols("W"), lstgcols("?"))
image(m, useRaster=T , col = stgpal, xaxt = "n", yaxt = "n", axes = F, breaks = 0.5 + (0:6) )
